% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ebrel-package.R
\name{run_ebrel_R}
\alias{run_ebrel_R}
\title{Run the ebrel optimization}
\usage{
run_ebrel_R(
  ebrel_obj,
  X0 = NULL,
  base_prob_X0 = 0.85,
  universal_disp_thres = 50,
  max_disp_steps = 30,
  roi_cap = 200,
  cluster_gap_cells = 25,
  alpha = 1,
  beta = 25,
  gamma = 100,
  sigma = 0.05,
  temp = 1000,
  step_proportion = 0.05,
  step_probability = 0.15,
  n_iterations = 10000,
  cooling_rate_c = 1,
  lam_enabled = FALSE,
  lam_target_mid = 0.44,
  lam_target_final = 0.05,
  lam_hold_frac = 0.6,
  lam_p = 2,
  min_iterations = 1000,
  acceptance_window = 1000,
  acceptance_thres = 0.01,
  iter_no_improve = 1000,
  improve_eps = 1e-06,
  seed = -1,
  verbose = FALSE
)
}
\arguments{
\item{ebrel_obj}{External pointer created by \code{create_ebrel_class_object_R()}.}

\item{X0}{Optional initial configuration.}

\item{base_prob_X0}{Numeric; probability of assigning \strong{no} habitat in a creation step.}

\item{universal_disp_thres}{Numeric; distance (in cells) after which universal dispersal is assumed.}

\item{max_disp_steps}{Numeric; dispersal limit factor (number of consecutive hops) applied as \code{D[sp] * max_disp_steps}.}

\item{roi_cap}{Numeric; capping the size of the region of interested (roi) to prevent ballooning.}

\item{alpha}{Numeric weight for target attainment.}

\item{beta}{Numeric weight for spatial aggregation.}

\item{gamma}{Numeric weight for costs.}

\item{sigma}{Numeric; controls distance weighting when selecting candidates.}

\item{temp}{Numeric initial temperature for simulated annealing.}

\item{step_proportion}{Numeric in (0, 1]; proportion of eligible cells to update per step.}

\item{step_probability}{Numeric in \link{0, 1}; probability of assigning any habitat to a cell.}

\item{n_iterations}{Integer > 0; maximum number of SA iterations.}

\item{cooling_rate_c}{Numeric > 0; cooling-rate control (used only when \code{lam_enabled = FALSE}).}

\item{lam_enabled}{Logical; enable Lam-style adaptive cooling rate control.}

\item{lam_target_mid}{Numeric target uphill acceptance rate for early/mid run.}

\item{lam_target_final}{Numeric target uphill acceptance rate at the end.}

\item{lam_hold_frac}{Numeric in \link{0, 1}; fraction of the run to hold \code{lam_target_mid} before decaying.}

\item{lam_p}{Numeric >= 1; damping exponent in Ben-Ameur correction.}

\item{min_iterations}{Integer >= 0; require at least this many iterations.}

\item{acceptance_window}{Integer > 0; window length for acceptance-rate estimation.}

\item{acceptance_thres}{Numeric; "low" acceptance threshold.}

\item{iter_no_improve}{Integer >= 0; consecutive iterations with no meaningful improvement.}

\item{improve_eps}{Numeric > 0; relative improvement needed to reset patience.}

\item{seed}{Integer; RNG seed (use -1 for non-deterministic/auto seed).}

\item{verbose}{Logical; print progress.}
}
\value{
A list. Replace with the exact structure you return, e.g.:
\itemize{
\item \code{X_best}: best configuration found.
\item \code{objective_trace}: numeric vector of objective values over iterations.
\item \code{acceptance_rate}: numeric; overall or rolling acceptance rate.
\item \code{iters}: integer; iterations executed.
}
}
\description{
Runs simulated-annealing optimisation on an \code{ebrel} object.
}
\examples{
\dontrun{
res <- run_ebrel_R(obj, n_iterations = 2000, verbose = TRUE)
}
}
