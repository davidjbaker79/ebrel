% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/prepare_ebrel_r_to_cpp.R
\name{prepare_ebrel_r_to_cpp}
\alias{prepare_ebrel_r_to_cpp}
\title{Create a C++-friendly object for EBREL optimization}
\usage{
prepare_ebrel_r_to_cpp(E_rast, C_rast, SD_rast, D_vec, SxH_mat, O_vec)
}
\arguments{
\item{E_rast}{A \code{SpatRaster} with \strong{n_h} layers: habitat suitability/categorical habitat per habitat option.}

\item{C_rast}{A \code{SpatRaster} with \strong{n_h} layers: conversion costs/constraints per habitat option.
Values \eqn{\ge} 1e11 indicate unavailable cells (kept as-is; interpreted downstream).}

\item{SD_rast}{A \code{SpatRaster} with \strong{n_s} layers: species/feature baseline distributions or constraints.}

\item{D_vec}{Numeric vector of length \strong{n_s}: maximum dispersal (in grid cells) for each species/feature.}

\item{SxH_mat}{Numeric/integer/logical matrix of shape \strong{n_s × n_h}: species–habitat associations (ideally 0/1).}

\item{O_vec}{Numeric vector of length \strong{n_s}: species/feature targets (e.g., proportional increases).}
}
\value{
A list with flattened numeric or integer vectors:
\describe{
\item{E}{length \code{n_cells * n_h}}
\item{C}{length \code{n_cells * n_h}}
\item{SD}{length \code{n_cells * n_s}}
\item{D}{length \code{n_s}}
\item{SxH}{length \code{n_s * n_h}}
\item{O}{length \code{n_s}}
}
}
\description{
Prepares raster and matrix data as flattened vectors suitable for passing to C++.
This function extracts and flattens relevant input rasters and matrices into a list
of vectors used by EBREL's C++ backend.
}
\details{
Let \code{n_cells <- dim_x * dim_y}, \code{n_h <- nlyr(E_rast)}, and \code{n_s <- nlyr(SD_rast)}.
Flattening is \strong{layer-major} (column-major on the \code{values(...)} matrix): all cells of layer 1,
then all cells of layer 2, etc. This yields vectors of lengths \code{n_cells * n_h} for habitat/cost
rasters and \code{n_cells * n_s} for species rasters.
}
\examples{
\dontrun{
obj <- prepare_ebrel_r_to_cpp(E_rast, C_rast, SD_rast, D_vec, SxH_mat, O_vec)
}
}
